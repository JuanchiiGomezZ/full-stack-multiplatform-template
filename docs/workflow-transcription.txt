00:00 Abuela, salió video de gentleman. ¿Qué hace 
locurísima, cósmica? Estamos un poquitito mejor  
00:06 de la garganta y hoy te vengo con un video 
que te va a volver loco. Te voy a enseñar  
00:10 todo lo que tenés que saber de agentes y 
una arquitectura espectacular, infalible,  
00:16 que te voy a ser totalmente sincero, me lo inventé 
y está funcionando impresionante. Así no más. ¿Y  
00:22 por qué te digo que me lo inventé? porque todo 
está progresando continuamente. Así que si te  
00:27 interesa todo esto y querés llevar tus proyectos a 
usar la IA como un campeón que una cosa allí loco,  
00:32 quédate en este videíto. Entonces, gente hermosa 
de mi corazón, ¿qué vamos a estar viendo hoy?  
00:38 Hoy vamos a estar aprendiendo cómo los agentes se 
pueden comunicar de forma increíble con ustedes.  
00:43 Claro que sí. Y prácticamente hacer by coding, 
pero saben que no me gusta decir by coding,  
00:48 me gusta decir software engineering cona 
correctamente. ¿De qué manera? de que puedas  
00:53 entrar a cualquier tipo de proyecto y puedas crear 
un ambiente increíble para que cualquier persona  
00:58 que quiera colaborar en ese proyecto o también 
vos usando la IA para poder generar cualquier  
01:03 tipo de feature o lo que sea, lo haga de forma 
increíble, correcta y rap. Pero primero tenemos  
01:09 que entender bastantes cositas. Recursos que te 
voy a recomendar right now. Atentos. Asients.  
01:15 Espectaculare. MD. Bien. Lo primero de todo, esto 
es un archivito markdown, por eso es MD de tipo de  
01:23 lectura, que es el archivo que utilizan todos los 
agentes. ¿Para qué? Para poder justamente entender  
01:29 el contexto de un proyecto. Y no solamente eso, 
sino que también te va a servir para poder decirle  
01:35 a la cómo queres que se comporte, cómo tiene que 
trabajar, cositas a tener en cuenta y muchas otras  
01:40 cosas más. ¿Por qué el Agen MD? prácticamente. 
Miren, el Redmi de toda la vida es lo que nosotros  
01:47 utilizamos para personas humanas. El Asient es 
para la gente, es un archivito que solamente los  
01:53 agentes tienen que entender. Así que les voy a dar 
unos tips para crear un Agenc MD correctamente. Ya  
01:57 lo van a ver, es una cosa dos. Vamos a entender 
también un poquitito el tema de las skills.  
02:01 Los agentes pueden utilizar skills y tienen una 
solución espectacular. Y no se lo voy a aplicar  
02:07 ahora. Quiero que sepan que existe esto porque 
después se lo voy a explicar con detallecitos,  
02:12 dibujitos y más. Y no solamente eso, tengo un 
proyecto que es mi proyecto del trabajo, bien,  
02:18 de mi empresa que es open source llamada Proler, 
que es de ciberseguridad en la nube cloud y está  
02:24 saliendo muy bien esto. Así que vamos con lo 
primero que tienen que saber es lo siguiente.  
02:28 Digamos que nosotros estamos trabajando dentro de 
un proyecto. Bueno, lo primero que vamos a tener,  
02:32 obviamente, es un buen horro. Llé. Este es el 
agente, sií, el famoso LLM, pero lo vamos a  
02:39 llamar un poquitito diferente, lo vamos a llamar 
agent, vamos a llamarlo así por ahora. Bien,  
02:43 esto puede ser, por ejemplo, Clo, puede 
ser, qué sé yo, GPT, lo que vos quieras,  
02:48 papurre. Lo importante es lo que viene. Ahora, 
nosotros tenemos el agente y obviamente vamos  
02:53 a tener lo que sería, ¿no? Un user, un usuario. 
El usuario hace unas peticiones a lo que es el  
03:00 agente. ¿Qué tendría que hacer el agente? Vamos a 
pon un poquito más abajo. Viene la gente hermoso  
03:04 de mi corazón, todo super buen hororro y le va 
a preguntar, obviamente, al código, a lo que  
03:09 se llama la codebase. Esta codebase es todo tu 
proyecto, pero acá tenemos un problema. Para que  
03:13 de todo ese código extraiga algo y de todo eso 
que extrae se lo manda al usuario, tenemos una  
03:19 complicación. Esto puede ser enorme. Bien, esto 
puede ser enorme. Entonces, si el agente tiene  
03:24 que revisar todo este código para poder devolverte 
lo que vos querés o implementar lo que vos querés,  
03:29 estamos complicados. Entonces ahí es cuando de 
entre medio de estas cositas va a existir el ACMD.  
03:35 Vamos a crearlo. Ahí lo tenemos. Entonces, ahora 
el agente va a consultar cómo tiene que trabajar  
03:41 con este Codebase. Va a obtener información 
directamente sobre, por ejemplo, dónde se  
03:47 encuentra tal cosa, en qué lugar podemos trabajar 
sobre otra, cómo trabajar con dicho proyecto,  
03:53 dónde tienen que ir los archivos, exactamente todo 
lo que tenemos dentro de proyecto, a lo que a mí  
03:58 me gusta llamar la parte cultural del proyecto. 
Bien, vas a ver la arquitectura, vas a ver todo  
04:03 el formato de carpetas, vas a ver un poquitito 
de todas las tecnologías, todo bien. Entonces,  
04:08 el agente le va a devolver toda esta información 
y con dicha información ahora bien, el Agenc MD  
04:14 le devuelve todo eso a la gente. Entonces, la 
gente ahora después de obtener información del  
04:18 Agen MD puede ir a trabajar con el Codebase de una 
forma mucho más rápida y eficiente, obteniendo una  
04:24 versión bien igual o mejor todavía de lo que va a 
obtener y pum, se lo manda de vuelta al usuario.  
04:30 para otra problema. Hay una recomendación, hay 
una recomendación y de ahí, gente, les recomiendo  
04:36 realmente esta página de agents. Porque les va 
a permitir obtener buenas prácticas estándares  
04:44 del mundo. Sí, junto también con el Aence MD. 
Una de las recomendaciones que van a ver es  
04:49 que Aence MD tiene que tener un tamaño dentro de 
todo razonable. Si ustedes tienen un muy grande,  
04:55 generalmente ustedes tendrán la mala concepción 
de que una gente cuanto más contexto tiene mejor  
04:60 trabaja. Es totalmente equivocado porque tiene 
demasiadas cosas a tener en cuenta. Tiene que  
05:04 procesar demasiado. Cuanto más tiene que procesar 
más puede alucinar y hacer lo que se le canta y de  
05:10 la nada hizo cualquier cosa. Entonces, el agente 
tiene que estar condensado y ser eficiente más o  
05:16 menos, gente. 250 líneas, 500 como máximo. Ahora, 
¿qué pasa si este código es una brutalidad? No  
05:22 podemos en Kinit. Entonces vamos a hacer una cosa. 
En vez de hacer un Agen MD para toda la Codbase,  
05:26 ¿qué pasa si hacemos mucho? Vamos con eso. 
Entonces miren que en cambio ahora directamente  
05:30 me voy de tener un AgenmD. Voy a tener múltiples 
AgenmD cada uno teniendo este es autenticación,  
05:36 este es el de UI y este es el de API, por ejemplo, 
donde cada uno tiene las particularidades de una  
05:42 parte diferente de la aplicación. Buenísimo. Pero, 
¿cómo ordenaríamos esto? Fantástico. Dentro de  
05:47 la codebase, en vez de tener una codebase y pum, 
toma todo, lo que vamos a tener es esta codebase  
05:52 dividida por features. Bien, por ejemplo, digamos 
un mono repo, un mono repo donde tenemos frontend,  
05:57 backend, como les digo. Entonces, tendríamos este 
el Aens MD dentro de la de la carpeta UI, el de  
06:03 API dentro de la carpeta de API, autenticación 
dentro de la carpeta de autenticación o lo que  
06:07 sea. Tenerlo dividido un poquito más sector 
actualizado, pero pasa algo. Entonces,  
06:10 ¿cómo hacemos? El agente cómo va a hacer para 
identificar dónde tiene que ir a consultar, porque  
06:15 estos son carpetas diferentes. Entonces, una cosa 
es yo me paro en una carpeta correspondiente y  
06:20 ejecuto la gente, entonces sabe que tiene que 
usar ese hermoso. Pero si estamos en el root  
06:24 de la aplicación, por ejemplo, en un mono repocos. 
Ahí viene el caso. Tiene que haber un agents root.  
06:30 Entonces ahora el agente va a consultar en el 
agent MD dónde está cada información. Entonces,  
06:35 por ejemplo, si yo el usuario le pregunto algo 
de UI, el agente va a entrar al agente root,  
06:41 que es el que prácticamente lidera todo, y este 
le va a decir, "Si querés algo de UI, paporri,  
06:46 lo tenés acá." Entonces de esa manera vamos a 
poder reducir justamente el contexto y darle el  
06:51 contexto suficiente solamente cuando necesitamos, 
pero pasa, esto se puede seguir creciendo. ¿Qué  
06:56 pasa si ahora no solamente tenemos algo de UI, 
sino que tenemos algo muy específico? ¿Cómo  
07:01 trabajar con React? ¿Cómo trabajar con Tys? ¿Cómo 
trabajar con Python? cómo trabajar con Yangjango,  
07:05 cómo trabajar, por ejemplo, dentro de la parte 
de identificación con eh tal y tal plugin o outa,  
07:11 cómo trabajamos con cosas específicas, concretas, 
con habilidades que tiene que tener nuestra gente.  
07:17 Y ahí es cuando entra el tema de el tema de las 
skills. Las skills son justamente eso, es una  
07:23 forma de poder reducir el contexto que nosotros 
le damos a la gente para que cuando realmente lo  
07:28 necesite tenga lo que quiera utilizar. Entonces, 
por ejemplo, digamos que ahora mi agente muy  
07:34 bonito está trabajando con todo este quilombo y 
claro, a medida que nosotros vamos pidiendo cosas,  
07:40 esto se va incrementando de recibe demasiado 
contexto al a un tiempo determinado. Bien,  
07:45 demasiado contexto y qué les dije yo cuanto 
más contexto tiene una gente, más loco se me  
07:50 pone. Entonces, en vez de tener todo esto, vamos 
a separarlo un poquitito más. Vamos a crear ahora  
07:56 lo que nosotros vamos a llamar una habilidad, 
una skill. Y vamos a tener muchas. Vamos a tener  
08:00 una React, vamos a tener otra, vamos con esta, 
Python, claro que sí. Y después podríamos tener  
08:06 muchas más. Digamos que vos siempre hacés los 
comits de cierta manera en tu aplicación para  
08:10 que seas recol. Bueno, fantástico, venís acá y 
te vas a hacer una, por ejemplo, para comics.  
08:15 Después digamos que tenés los pur request de tu 
aplicación de una forma muy determinada. No hay  
08:20 ningún tipo de problema, papurri. Después vas a 
venir acá y te vas a crear uno de PR. En resumen,  
08:25 podemos hacer de todo. Esto es una forma de 
identificar flujos de trabajo, formatos, eh  
08:31 todo lo que es cultural, lo que siempre les digo. 
Y también tarea repetitiva. Yo lo utilizo para,  
08:37 por ejemplo, yo cada vez que hago un cambio en mi 
repositorio de Gentleman Dots, que tiene todas mis  
08:41 configuraciones y demás, link en la descripción, 
yo tengo que además de hacer un release en Gend.  
08:46 Dots, también tengo que hacer un release en home 
porque también se los doy por ahí. Entonces,  
08:50 todo ese proceso que tiene que agarrar, buscar un 
hash, hacer un montón de cosas, lo hace automático  
08:55 porque tengo una skill que ya sabe todos esos 
pasos que tengo que hacer y solamente la Entonces,  
09:00 ¿cómo ahora esto funciona con el tema de los 
agentes? Bueno, los agentes realmente y se lo  
09:05 digo de verdad, funcionan de forma automática, 
automática. Ellos van, pum, y pican esto cuando  
09:12 lo necesitan. Bien, cuando vos le decís, por 
ejemplo, esto tiene un trigger, se llama,  
09:16 vos le decís, "Vas a trabajar con Python tenés que 
leer esto. Vas a trabajar, vas a hacer un comit,  
09:21 dale con esto. Tenés que hacer algo de react, le 
das con este. ¿Querés hacer un p request?" Le das  
09:26 con este. Bien, esa sería la idea conceptual. Es 
más, vos te vas a en la documentación de Claudio,  
09:31 te vas a ir en la documentación de Gemini, te 
vas a la documentación de GPT y todos te dicen,  
09:35 "Lo identificamos de manera automática, siempre 
y cuando pongas dentro una carpeta skills de tu  
09:41 punto claw o tu punto gemini o tu punto eh, no me 
acuerdo cuál el otro, codex creo que era." Siempre  
09:47 que tengas eso te vamos a hablar las skills 
y lo aplicamos de manera automática. Mentira,  
09:51 porque realmente los modelos generalmente lo toman 
como una sugerencia. Entonces ahí les voy a dar un  
09:57 tip más. Claro que sí. Les voy a dar un tip más. 
En el Asiance root y en cada uno de estos les voy  
10:03 a mostrar una forma de vuelta. Yo me invento cosas 
y funcionan, yo se los digo. Mi recomendación de  
10:08 aquí de arquitecto. Vamos a darle una lista a cada 
uno de ellos con qué skills pueden trabajarse y  
10:15 cuándo se van a triguerear. Entonces, ahora vamos 
a ver la estructura de cada skill. Pero cada una  
10:21 de estas skills va a tener un scope, que es dónde, 
bien, dónde está involucrado. Por ejemplo, React,  
10:26 ¿dónde va a estar gente? En API no va a estar 
en UI. Perfecto. Eh, comit, eso es genérico,  
10:32 queda en el root. Pull request, queda en el root. 
Se entiende lo que les digo. Entonces de esa  
10:36 manera lo podemos ir ahí accionando. Entonces, ya 
sabiendo todo esto, gente hermosa de mi corazón,  
10:41 creo que tenemos el contexto suficiente 
también como para hablar de subagentes,  
10:46 porque acá agarrate los subagentes antes se 
trabajaban también como si fueran skills.  
10:51 Cada subagente era un agente, obviamente, pero 
más chiquitito, con un contexto más pequeño y  
10:57 que a su vez tenía un conjunto de habilidades 
eh ya predispuestas. Pero hay una realidad,  
11:01 era una solución para el tema de no utilizar tan 
contexto. Bien, ¿por qué era la solución? Fácil.  
11:07 Lo que hace hace es que la gente principal, 
esta hermosura que tenemos acá, va a tener  
11:12 un contexto inicial y ahora no se va a llamar más 
agente, se va a llamar agente, agarrate con esto,  
11:19 orquestrador. ¿Por qué? Porque es el que va a 
manejar a todos los subagentes. Entonces, digamos  
11:24 que nosotros tenemos que hacer tareas repetitivas 
y en paralelo. Por ejemplo, vamos a agarrar  
11:28 editar 500 archivos. a la pelota. Bueno, en vez de 
agarrar y que este vaya uno por uno cambiando o o  
11:35 porque lo hace, se haga un script para editar todo 
de una, lo que va a hacer es generar subagentes  
11:40 que lo hagan por él. Espectacular. ¿Y por qué 
eso? Porque no se ensucia. ¿Cómo trabaja un  
11:45 agente y un subagente? De la siguiente manera. Ya 
les dije, tenemos entonces lo que sería un agente  
11:51 orquestrador y este puede generar un nmero, claro 
que sí, es nmero de subagentes. Vamos a ponerle  
11:60 con el famoso S con el famoso SA. Entonces, de 
esta manera ya lo tenemos identificado que podemos  
12:07 hacer muchos subagentes. Ahora, el contexto 
entre cada uno es independiente. ¿Qué quiere  
12:13 decir esto? Porque claro, yo tengo acá bien, hago 
como una burbujita más, un cuadradito mejor. Esto  
12:18 tiene su propio contexto y el subagente también 
tiene su propio contexto. Y cuando esto termina,  
12:24 ¿cómo le dice al otro que terminó? Muy fácil. El 
suagente trabaja, hace lo que tenga que hacer,  
12:30 viene a hacer así se hace el trabajito y después 
lo que devuelve es al orquestrador le devuelve un  
12:38 resumen de todo lo que hizo. Nada más. Entonces, 
claro, esto va a crecer, sí crece un poquitito  
12:44 más el contexto, pero apenitas. ¿Por qué? 
Porque todo el proceso, todo lo que estuvo  
12:49 trabajando por adentro no lo tiene que agregar 
al contexto, solamente que pasó. Entonces,  
12:53 si nosotros sumamos subagentes con skills bien 
organizados, con agents y todo, tenemos una  
12:59 arquitectura de la gran flauta. Vamos a ver cómo 
se aplica esto ahora sí en un repositorio. Vamos  
13:05 con Ya estamos acá en el repositorio hermoso de 
Prowler y obviamente vamos a dar unazo porque ya  
13:10 sé que ustedes son unos asquerosos y son bastante 
chimenguencha con los ojos miopes y no ven un pomo  
13:16 igual que yo. Entonces acá tenemos lo que sería mi 
proyecto de trabajo de vuelta. Open Sor, lo pueden  
13:22 buscar en GitHub Brawler Cloud y ahí lo van a 
tener y quiero que vean cómo está organizado.  
13:27 Por un lado tenemos obviamente el ATS MD y el Asi 
además de dar información sobre todo lo que pasa  
13:34 en el proyecto, ven que tiene un project overview, 
también cómo trabajar un poquitito con Python,  
13:40 cómo eso son los guidelines de comit y request y 
demás. va a tener esta parte de aquí, ahí la ven,  
13:45 que tiene todas las skills genéricas, tycrip, 
React, NS, Twin, Playri, PES, etcétera, y después  
13:54 específicas de Prwler, cómo trabajar en la UI de 
Prwler, cómo trabajar en la API de Prwler. ¿Por  
13:59 qué todo esto? Muy sencillo, somos open source. Al 
ser open source tenemos que dar la posibilidad a  
14:04 contribuyentes de que puedan contribuir, pero de 
una manera controlada, una manera culturalmente  
14:10 controlada, que si vos querés aplicar una 
contribución sea acorde a como nosotros ya  
14:15 trabajamos. Entonces, ustedes también piensen 
en una persona que recién entra a trabajar en  
14:19 un proyecto. Esto está increíble, increíble para 
poder ayudar a esa persona a involucrarse lo más  
14:25 rápido posible dentro de tu proyecto. Entonces, 
una cosa que me di cuenta fundamental es lo que  
14:31 les decía. Claro, está buenísimo. Tenemos todas 
las skills, tenemos todo. Wow. Claro, el tema es  
14:36 que la gente, por más que yo le tenga, le ponga 
acá todas las skills que empezó poniéndose acá,  
14:41 porque hay una hermosura que no voy a nombrar, 
tipo de gente que no nombr que ni siquiera tiene  
14:46 skills todavía. Vamos a ver si le meten todavía, 
pero no quiero decir cuál porque por ahí ya lo  
14:50 arreglaron, ¿eh? Pero para el momento que yo estoy 
haciendo esto, no tiene skills. Entonces le estoy  
14:55 diciendo que por acá lea un archivo cuando tiene 
que hacer algo y se carga ese contexto. Bien,  
14:60 es una forma como de hackear el tema de las 
skills. Bien, sigamos. Le tuve que agregar esto,  
15:04 gente. Autoinvocar las skills. Claro que sí. Y acá 
le dije, cada vez que vos tengas que hacer alguna  
15:09 de estas acciones, vas a tener que ir a hacer 
cualquiera de las skills que tenés arriba. Por  
15:14 eso ahí dice API, project overview, esto, el otro, 
pa pa pa. y tiene que autoinvocar las skills,  
15:21 si no estamos en el horno. Esto no funciona así 
no más. Por eso mismo, si ustedes van también  
15:26 a la UI y vamos a este Hems MD que tenemos acá, 
vamos a encontrar más o menos lo mismo. Tenemos  
15:32 las referencias de todas las skills. ¿Ven? 
Vean que son directorios porque están todas  
15:37 en un directorio particular y le digo que las 
autoinvoque. Cada vez que tengas que trabajar  
15:41 con un app, router, un server actions, pum, ándate 
en XJS. Cada vez que tengas que escribir un test,  
15:46 te vas a prer test. Cada vez que tengas que 
crear o modificar un componente de React, te vas  
15:50 a Proler UI y así pa le voy dando información, 
le estoy obligando a cómo accionar. Entonces,  
15:57 sabiendo esto, vamos a ver las skills en 
particular. El formato de las skills es muy  
16:02 sencillo, es una carpeta skills, adentro ponen 
la que ustedes quieran. Vamos a ir, por ejemplo,  
16:07 de NextJS y adentro van a ver que tiene un skid 
MD. Pumba. Y esto que están viendo, todo lo que  
16:12 está entre líneas viene de la línea uno a lo 
que es la 12. Es lo que se llama una metadata,  
16:18 es información acerca de una skill y tenemos 
nombre de la skill, una descripción que dice  
16:23 cuándo ejecutarlo. Bien, tiene un trigger, no sé 
si lo ven acá, y dice cuando estés trabajando con  
16:28 XJS, routing, server action, data fetching, lo 
que sea, vas a llamar este skill. Esa es la idea,  
16:33 una licencia, la metadata en sí, por ejemplo, 
le decimos quién es el autor, por el cloud,  
16:38 porque obviamente lo hice con ellos. Bien, ¿cuál 
versión tiene? El scope. Esto es un invento mío,  
16:43 no es una convención, pero es un invento mío. Ya 
van a ver por qué. Bien, pero tiene un scope. Esto  
16:47 es du. Luego tenemos un apartado de autoinvocar 
router server actions. Bien, también metadata, ya  
16:53 van a ver por qué. Y por último, ¿qué herramientas 
puede utilizar? Porque claro, un agente tiene un  
16:58 conjunto de herramientas, lectura, escritura, 
edición, poder utilizar herramientas como bash  
17:05 grab, como dice acá, hacer búsquedas de internet, 
lo que sea. Bien, vos si quisieras podrías  
17:10 controlar qué le das a una skill, si solamente 
es una skill que hace documentaciones, lectura y  
17:15 escritura y por ahí porque querés que solamente 
vea del repositorio. Si querés documentaciones  
17:19 técnicas por ahí, querés que busque en internet, 
depende. Y ahora sí, cuando yo me meta en esto,  
17:24 vamos a ver cómo es la convención de estructura 
de mi proyecto para trabajar con XJS. Un resumen,  
17:30 cómo trabajar con una server action, cómo 
trabajar bien con una server componeting,  
17:36 resumen, información sobre cómo trabajar en 
NextJs. Pero, ¿qué pasa si necesitamos algo  
17:41 más esto más complejo, más enquilombado? No pasa 
nada, locurísima. Mira, vamos a entrar a Proller  
17:47 Compliance. vas a ver que ahora para poder generar 
una compliance dentro de mi proyecto, olvídense  
17:51 lo que es una compliance, miren la estructura, 
tenemos un skill nuevamente con el trigger y todo,  
17:55 pero esta además de decir cuándo se tiene que 
utilizar, también tiene la estructura igual que  
18:01 lo de NextJs. Seguimos, seguimos, seguimos. 
Pero al final de todo, resources y acá tiene  
18:06 templates y documentación. ¿Qué es esto? Si yo 
voy a la parte de assets, tengo ejemplos. Tengo  
18:12 ejemplos de cómo es una compliance. Y si yo veía 
referencias, está la documentación oficial que  
18:18 está dentro del repositorio sobre cómo hacer una 
compliance y todo lo que tenga que ver con una  
18:22 compliance. Entonces el clásico, la mejor forma 
de trabajar con la y decirle que haga algo y que  
18:26 lo haga one shot prácticamente, ojalá es darle 
una versión detallada si la necesita y ejemplos,  
18:32 cuanto más ejemplo le des, mejor. Entonces esto es 
un conjunto de todo. Va a venir acá, va a leer la  
18:39 skill y cuando vea que necesita más, va a ver que 
tiene ejemplos para seguir y demás. ¿Bien? Ahora  
18:44 hay un problema. Muy lindo las skills, muy lindo 
todo. Ya sabemos ahora cómo actúa y cómo trabaja,  
18:49 pero nos falta una parte importante. Soport. 
No todos soportan un agen MD. Si yo vemos con  
18:54 Claudio, con el bueno de Claudio, el Agen MD 
no se lo lee. ¿Qué tiene que leer Claudio? El  
18:59 cloue.md. Cada uno tiene un nombre diferente, 
generalmente. Entonces lo que yo hice es que si  
19:05 entras en esta carpatita de skidos, tiras para 
abajo, bien, vas a ver que hay un setup sh de  
19:10 vuelta. Todo esto lo pueden sacar de repositorio 
de Prwler. Es interesante. ¿Y qué hace esto? Le  
19:14 doy soporte a todo. Le doy soporte a Cloud Code, a 
Gemini, a Codex y a GitHub Copilot. Bien, entonces  
19:21 esto lo que hace es instalar todas las skills 
de la manera que espera cada agente. Entonces,  
19:28 ahora voy a ejecutar un comando porque ustedes 
son hermosos. Bien, ahí tenemos el Open Code ya  
19:32 listo para la acción y vamos a hacer justamente 
skills setup/sups pa. Y acá lo interesante que  
19:39 tiene que me va a preguntar qué queres instalar. 
Vamos a ponerle todo, ¿les parece bien? Yo quiero,  
19:43 por ejemplo, all, quiero todo pa, elige 
todo y le damos un buen enter. Bien,  
19:48 y ahí está instalando. ¿Y qué es instalando? Ya 
lo van a ver. Ahí terminó. Esto lo que va a hacer  
19:52 es copiar todas las skills dentro de CLO, Codex, 
Gemini y GitHub. Y miren que GitHub es un solo  
19:59 archivo. ¿Ven que hay un asqueroso que no soporta 
skills? Bueno, yo les digo no más. Bueno, no  
20:03 quiero decir nada. Ojalá que lo hayan arreglado al 
momento que ustedes vean este, pero por lo menos  
20:07 por ahora es así. Ahora, otra cosa importante, 
además de eso, si yo por ejemplo voy acá arriba,  
20:13 vamos a encontrar que tengo cada uno de los 
que yo le decía, Clo, Codex, Gemini y demás,  
20:18 pero no sería medio lógico andar copiando esta 
carpeta 20 veces. Exactamente. Por eso si yo vengo  
20:24 ahora y lo veo de esta manera, van a ver que dice 
que las skills en verdad son un link simbólico a  
20:30 users anambujaglia trabajo, Prowler skills. En 
resumen, esto lo que ha hecho realmente es ir  
20:36 a la carpeta skills, agarrar todas las que están 
acá y ha creado un link simbólico dentro de cada  
20:41 una. Hermoso, espectacular. Pero eso no termina 
aquí. Aún hay más. Si ustedes van aquí abajo van a  
20:48 encontrar que tienen un Clemed, ¿qué hace también 
ese script? Copia el agents, lo pega y le cambia  
20:53 el nombre y le pones cloud. Entonces ahora ya 
funciona para Cloude. Aplauso. Vamos pibe. Bien,  
20:58 es tan sencillo como eso. Y de la misma manera, un 
Jamy K MD también funciona para J. Estamos bien,  
21:05 estamos acordes. Alan, hay un problema. Esto no es 
mantenible. ¿Por qué no es mantenible? Y cada vez  
21:11 que creas una skill tenés que ir a cambiarlo 20 
lugares distintos. No pasa nada. Y sabes por qué  
21:16 no pasa nada, yo te voy a explicar. Mira, digamos 
que yo voy y quiero agregar en este de Gemini,  
21:20 que está muy bonito, por cierto, una skill nueva. 
Lo voy a agregar a mano acá después de haberlo  
21:24 creado y tal, ¿no? Porque yo tengo dos skills 
hechas para traer repetitivas. Esas skills son,  
21:30 primero de todo, tenemos el skill creator, 
que justamente, adivinen para qué va a ser,  
21:34 para crear skills. O sea, cada vez que yo crea, 
quiera crear una skill, le digo que utilice esta  
21:38 skill, herm. Bien. Y acá tengo un template 
al cual seguir. Miren qué bonito, hermoso,  
21:43 ¿no? Divinicio. Y después tengo un skill de 
sincronización. Luego de crear lo que es la skill,  
21:48 va a llamar a esta otra skill que va a justamente 
sincronizar todo. ¿Y qué es sincronizar? Va a  
21:53 ir a todos los agents MD y va a agregar la skill 
correspondiente. Punto. Es así de fácil. ¿En qué  
21:58 termina todo? Vamos a verlo. Ahora sí, nos vamos a 
ir a Open Code Papurri. Entonces, estoy dentro acá  
22:03 de eh mi proyectito y le voy a decir, por ejemplo, 
qué skills tienes disponibles. Y miren lo que va  
22:09 a pasar. Esto ahora me va a hacer una colección de 
todos los skills que tengo dentro del proyecto. Yo  
22:15 ahora mismo tengo algunos dentro de mi confug eh 
confug de mi configuración del user de mi máquina,  
22:21 por lo cual siempre están para cualquier proyecto, 
pero obviamente yo quiero algo para Prwler y acá  
22:26 lo tenemos. Sí, acá lo tenemos. Entonces, vamos 
a hacer algo, si les parece bien. Entonces,  
22:32 vamos a pedirle, por ejemplo, quiero que crees un 
botón dentro de la carpeta UI, ¿sí? Por ejemplo,  
22:38 dentro de la carpeta de UI, eh, para cargar un 
finding. No importa lo que sea, gente, pero punto.  
22:46 Para cargar un finding es algo propio de Prwler. 
De vuelta es una herramienta de ciberseguridad.  
22:51 Un finding es una problemática. encontrar una 
problemática dentro de un recurso, puede ser AWS,  
22:56 puede ser lo que sea. Y miren lo que dice. 
Voy a cargar el screen de Prer UI para seguir  
22:59 los patrones correctos de proyecto y esperar la 
estructura actual. Bien, explorar la estructura  
23:03 actual. Ahí lo tenemos. Cargó skill name prer 
UI. Está explorando la tarea. Si yo quisiera  
23:08 podría ser control X y derecha y puedo ver lo 
que está trabajando justamente el subagente.  
23:15 ¿Ven lo que les digo? Es el subagente ejecutando 
justamente esa skill. Hermoso. Ahora vamos a hacer  
23:22 control X y para arriba. Esto es Open Code, a 
mí me encanta. Vamos a ponerle continúa porque  
23:27 a propósito lo paré para que ustedes lo puedan 
ver. Sí. Entonces ahí sigue. Ahí está delegando.  
23:32 Hermoso y pumba. Ahora vamos a poder entrar de 
vuelta y verlo. Vamos a poner de vuelta control  
23:37 X derecha. Ahora sí, ahí lo tienen. Está haciendo 
los glob, los GRP, todo lo que ustedes quieran,  
23:42 investigando todos los archivos que hay dentro 
de la parte de UI. Pero quiero que vean cómo  
23:47 actúa el orquestrador con unos subagentes. Es una 
prompt. le dice el orquestrador a la gente, "Ey,  
23:53 explorar la estructura de la UI para findings en 
Prer. Tengo que entender qué componentes existen,  
23:59 qué acciones existen. Miren los patrones para 
hacer botones, bien, que ya están dentro de  
24:04 la parte de findings, etcétera. Entonces, miren 
lo que está haciendo. Le hace un resumen y este  
24:10 hermosísimo resumen y de acciones y de todo se lo 
va a mandar al orquestrador. Así que ahí vamos a  
24:16 volver cuando usted termine. Ahí está, ya le dio 
el resultado y te dice, "Ahora el programa ya  
24:21 es completo. Antes de escribir código tengo que 
aclarar algo importante. Esto, gente, es porque  
24:25 tiene mi agente gentleman, como lo pueden ver acá, 
que yo le dije que sea una persona muy bonita, muy  
24:31 linda y prácticamente que te haga preguntas, que 
te trate de enseñar y que no haga código porque sí  
24:37 que vos lo lleves al resultado. Entonces, cuando 
vos decís cargar un finding, ¿a qué te referís?  
24:42 Importar finding de un archivo, crear un finding 
manual, disparar un scan." Vamos a decirle,  
24:46 por ejemplo, quiero crear un botón reutilizable 
que pueda ser utilizado para lanzar un scan. Vamos  
24:54 a ver qué pasa. Entonces, ahí está, ya está claro. 
Va a ver cómo se eh se lanzan justamente los  
24:58 scans. Le da para adelante. Ahí volvió. Excelente. 
Ya tengo el panorama completo. Necesito abir el  
25:02 código actual del botón y el formulario para 
crearlo consistente. Te da toda la información,  
25:06 te dice, "¿Qué tipo de de abstracción queres 
hacer? Botones, est." Entonces, quiero que vean  
25:10 algo. Una de las ventajas que tiene también 
el tema de las skills es quiero que revises  
25:15 la skill de UI y de React, bien, de proler vamos 
a poner y de React para entender qué puedo hacer  
25:23 y listo. Entonces, ahora también podemos llamar a 
las skills, ¿lo ven? Podemos llamar a las skills.  
25:28 De esa manera podemos ya tener culturalmente a 
necesidad cómo implementar algo. Bien, pero hay  
25:35 una cosa más que no les comenté. ¿Se acuerdan 
que yo les dije que me había inventado cosas?  
25:39 Dentro de esas cosas que me menté, yo les dije 
que tenía algo de un scope, ¿se acuerdan? Y un  
25:43 outoke. Y y eso es porque dentro de la parte de 
skill sync hay un archivo y es este que es otro  
25:51 script espectacular. Claro que vamos a ejecutarlo 
y yo creo que les va a volar la cabeza. Vamos a  
25:56 entrar de vuelta a la parte de skills. Vamos 
a ir justamente ahora al skill sync y vamos  
26:02 a ejecutar punto barra sync. Pumba, y ahí lo 
tenemos. Entonces, esto lo que va a hacer es ir  
26:09 a cada agente que nosotros tenemos y dependiendo 
justamente la property que yo les dije de scope,  
26:16 bien, va a meterlo donde tiene que ir. Entonces 
ahora todas las skill que yo tengo las revisó,  
26:21 las aplica. Por ejemplo, si acá el scope dice UI, 
lo meterá en UI. Si dice API, lo meterán API y SK,  
26:28 lo meterán en SK. Si es de root, lo meterán en 
root. Bien. Y también me está diciendo cuáles de  
26:33 esos no tienen la metadata de scope, ¿sí? Para ver 
cuándo ejecutarse, ¿por qué? Porque son genéricos,  
26:39 entonces no lo requiero. Y de esa manera ahora si 
yo, por ejemplo, vamos a abrir de vuelta acá y yo  
26:45 bajo, por ejemplo, al agents MD, bien, acá vamos, 
Agents MD, vamos a ver que ahora tenemos el skill  
26:51 creator, el PR do Dogs, tenemos otros. Bien, ahí 
lo tenemos. Hay más. Si yo ahora, por ejemplo,  
26:57 voy al agence de UI, van a ver otra vez que si 
yo voy para arriba tenemos más bien agregado  
27:04 nuevos elementos a estas skills. Entonces 
esa será la idea, justamente poder agarrar  
27:09 y trabajar de esta manera, todo sincronizado 
y todo bonito. Y gente hermosa de mi corazón,  
27:15 espero realmente que este vídeo les sirva. 
Es un curso completo. Traté de actualizar y  
27:20 explicar todo lo más posible de cómo trabajar con 
la IA, cómo se utilizan las skills, cómo trabajar  
27:25 correctamente con el tema de los agents y muchas 
otras cosas más. Así que gente de vuelta les dejo  
27:30 el repositorio de Prwler en la descripción para 
que lo puedan ir a investigar, para que vean toda  
27:34 la arquitectura que hemos planteado dentro del 
mismo. Los quiero muchísimo y ya saben, le dan  
27:38 una buena suscribida, le dan un buen abuela, salió 
video de gentleman, bien todo ese tipo de cosas  
27:45 que a mí me encantan de ustedes. Éxitos. Dejen en 
los comentarios si lo van a tratar de utilizar o  
27:49 si no les sirve para nada. Nos vemos. Chao. Nos 
vimos. Abuela, salió video de gentleman. Yeah.